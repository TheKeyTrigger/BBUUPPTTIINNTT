Web实时通信 E. Rescorla 
互联网草案 去读那些**的手册
预期状态：将会标准化的草案 2018年1月22日
到期日：2018年7月26日
                   Web实时通信的安全注意事项                 draft-ietf-rtcweb-security-10
摘要 

   WebRTC是一个协议套件，用于可以在浏览器中部署的实时应用程序-“Web上的实时通信”。
   本文档定义了WebRTC威胁模型，并分析了该模型中WebRTC的安全威胁。

WebRTC安全互联网草案 2018年1月
 
   本文档可能包含IETF文档或IETF贡献的材料，这些材料在2008年11月10日之前发 布或公开。控制某些文档材料版权的人员此可能还未授予IETF Trust在IETF标准流程之外修改此类材料的许可。
   如果没有从版权控制者那里获得足够的许可，本文档不得在IETF标准流程之外进行修改，并且其衍生作品可能不允许在IETF标准流程之外创建，除了将其格式化以便作为RFC发布或将其翻译成非英语语言。

   1.简介 
   Web上的实时通信（RTCWEB）工作组的任务是标准化Web浏览器之间实时通信的协议，通常称为“WebRTC”[ID.ietf-rtcweb-overview]。WebRTC技术的主要用例是实时音频/视频呼叫，Web会议和直接数据传输。与大多数传统的实时系统不同，（例如，基于SIP的[RFC3261]软电话）WebRTC通信由某些Web服务器直接控制。一个简单的案例如下所示。

   在图1所示的系统中，Alice和Bob都有支持WebRTC的浏览器和他们访问一些运营
   呼叫服务的Web服务器。他们的每个浏览器都提供标准化JavaScript的API（实现为浏览器内置函数），Web服务器使用这些API来建立Alice和Bob之间的呼叫。
   Web服务器还用作在浏览器之间传输控制消息的信令通道。虽然该系统在
   拓扑上类似于传统的基于SIP的系统（Web服务器提供信令服务，浏览器提供
   软电话），但控制已转移到中央Web服务器; 浏览器只是简单地提供了呼叫服务使用的API点。如对于任何Web应用程序，Web服务器可以在服务器和浏览器的JavaScript之间移动逻辑，但不论代码在何处执行，它最终都在服务器的控制之下。

   显而易见，这种类型的系统暴露出了超越传统VoIP系统的新的安全挑战。在某些时候，它需要与恶意呼叫服务相抗衡。例如，如果调用的服务可能会导致浏览器拨打电话，那么在任何时候它选择的任何被叫方这个工具都可以在用户不知情的情况下窃听用户的计算机，这只需要通过发出呼叫的一些记录服务。更危险的是，如果暴露的API允许服务器指示浏览器发送任意内容，它们可以用这种漏洞绕过防火墙或挂载拒绝服务攻击。任何成功的系统都需要抵御这种和其他网络攻击。

   配套文档[ID.ietf-rtcweb-security-arch]描述了
   旨在解决本
   文档中提出的问题的安全体系结构。
   2.术语 
   关键词“必须”，“必须”，“必须”，“应该”，“不应该”，
   “应该”，“不应该”，“推荐”，“可以”和“可选”本
   文档的解释如RFC 2119 [RFC2119]中所述。
   3.浏览器威胁模型
   WebRTC的安全要求直接遵循保护用户的浏览器工作要求。Huang等人[huang-w2sp]把核心浏览器安全保障总结如下：

      用户可以安全地访问任意网站并执行这些网站提供的脚本。

   重要的是要意识到这包括任意执行恶意脚本的站点。这个要求的动机很简单：
   攻击者引导用户转移到他们选择的站点是容易实现的。
   例如，攻击者可以购买显示广告，该广告将用户（自动地或通过用户点击）引导到他们的含有恶意脚本的站点，此时浏览器将执行攻击脚本。
   因此，只有查看任意恶意页面是安全的才是重要的。当然，浏览器不可避免地存在BUG使得它们达不到此目标，但任何新的WebRTC系统功能都必须以满足此标准来设计。
   本节的其余部分提供了更多的关于现有Web安全模型的背景知识。
   
   在这个模型中，浏览器从用户的角度上和在某种程度上从服务器角度充当可信计算基础（TCB）。虽然服务器提供的HTML和JavaScript（JS）可以使浏览器执行各种操作，但这些脚本在沙箱中运行，将它们与用户的计算机和其他服务器都相互隔离，详细如下所述。

   传统上，我们既指能够诱导用户访问恶意网站但不能控制网络的Web攻击者，也指能够控制用户网络的网络攻击者。网络攻击者对应[RFC3552]“Internet威胁模型”。请注意，对于非HTTPS流量，网络攻击者也是Web攻击者，因为它可以像任何非HTTPS站点一样注入流量。因此，在分析HTTP连接时，我们必须假设
   流量在流向攻击者。
   3.1 访问本地资源 
   虽然浏览器可以访问本地资源，如密钥，文件，摄像头和麦克风，但它严格限制或
   禁止Web服务器访问这些相同的资源。例如，尽管有可能产生一个HTML表单，将会   允许文件上传，但是脚本不能未经用户同意这样做，并且事实上甚至不能指定一个特定的文件（例如，/etc/passwd文件）; 用户必须明确选择该文件并同意上传。
   [注意：在很多情况下，浏览器是明确设计避免对话框的语义为“点击这里让自己疯掉”，因为广泛的研究表明用户在这种情况下很容易选择同意。] 

   类似地，虽然Flash程序（SWF）[SWF]可以访问摄像头和麦克风，但他们明确要求用户同意该访问权限。此外，某些资源无法通过浏览器访问。例如，没有方法可以直接从脚本运行特定可执行文件（尽管用户可以诱导下载可执行文件并运行它们）。
   3.2. 同源策略 
   许多其他资源可以访问但是是孤立的。例如，虽然允许脚本通过XMLHttpRequest（）API发出HTTP请求，但不允许将这些请求发送到任何服务器，而是仅允许与脚本同源的服务器 [RFC6454]（尽管CORS[CORS]和WebSockets[ RFC6455]提供了一个逃避限制，如下所述。）这个同源策略（SOP）可防止服务器A通过用户的浏览器对服务器B发起攻击，从而保护用户（比如，用户凭据不被滥用）和服务器B（比如，不受DoS攻击）。
   更一般地说，SOP强制每个站点的脚本在他们自己的隔离沙箱中运行。虽然存在允许它们进行交互的技术，但这些交互通常必须是相互共识的（由每个站点）并且仅限于某些通道。例如，同源的多个页面/浏览器窗格可以读取彼此的JS变量，但来自不同来源的页面——甚至来自同一页面上不同来源的iframe——不能读取彼此的JS变量。
   3.3. 绕过SOP：CORS，WebSockets和共识通信
   虽然SOP提供了重要的安全功能，但它也使得编写某些类别的应用程序变得不方便。特别是mash-ups，其中源点A的脚本使用来自源点B的资源，只能通过一定的hackery来实现。
   W3C跨源资源共享（CORS）规范[CORS]是对此需求的响应。在CORS中，当源点A的脚本执行原本禁止的跨源请求时，浏览器会与目标服务器通信以确定是否愿意允许来自A的跨源请求。如果愿意，则浏览器就会允许请求。这种共识验证过程旨在安全地允许跨源请求。

   尽管CORS是设计目的是允许跨源HTTP请求，但是WebSockets [RFC6455]允许跨源建立透明通道。一旦从脚本到站点建立了WebSockets连接，脚本就可以交换它想要交换的任何流量，而不需要将其构建为一系列HTTP请求/响应事务。与CORS一样，WebSockets事务以共识验证阶段开始，以避免允许脚本简单地将任意数据发送到另一个服务器或客户端。

   虽然同意验证在概念上很简单——只需在开始交换真实数据之前进行握手——经验表明设计正确的同意验证系统是具有难度的。特别Huang等人在[huang-w2sp]中已经展示了在现有的Java和Flash共识验证技术以及WebSockets握手的简化版本中的漏洞。
   特别重要的是要警惕交叉协议的攻击，在交叉协议攻击中脚本生成某些非Web协议状态机可接受的流量。为了抵御这种形式的攻击，WebSockets采用了一种掩码技术，旨在将线路上的比特流随机化，从而使生成类似已存在协议的流量变得更加困难。


Internet-Draft WebRTC Security 2018年1月

4. WebRTC应用程序的安全性

4.1。访问本地设备
 
   如第1节所述，允许任意站点发起呼叫
   违反了核心Web安全保障; 如果没有
   对本地设备的访问限制，任何恶意站点都可能会对
   用户造成错误。至少，任何站点都不可能在
   未经用户同意的情况下向任意位置发起呼叫。
   然而，这立即引发了一个问题，
   即用户同意的范围应该是什么。

   为了让用户做出明智的决定
   为了允许呼叫（因此他的摄像头和麦克风输入被
   路由到某处），他必须了解请求
   访问的人，媒体的去向，或两者兼而有之。如下所述，有
   两种基本的概念模型：

   1。您将媒体发送给实体A，因为您想
       与实体A（例如，您的母亲）交谈。

   2.实体A（例如，呼叫服务）要求访问用户的
       设备，并保证它将媒体转移到
       实体B（例如，您的母亲）。

   在任何一种情况下，身份都是任何同意决定的核心。
   而且，浏览器连接的一方的身份是
   所有浏览器都可以有意义地执行; 如果您正在呼叫A，则
   A可以简单地将媒体转发给C.同样，如果您授权A 
   向B发出呼叫，则A可以呼叫C。在任何一种情况下，所有
   浏览器都能够验证并检查
   控制媒体所在位置的任何人的授权。媒体的目标
   当然可以宣传安全/隐私政策，但这不是
   浏览器可以强制执行的。即便如此，还有各种
   不同的同意方案可以激发不同的技术同意
   机制。我们将在下面的部分中讨论这些机制。

   了解同意访问本地设备非常重要
   在很大程度上与同意通过
   网络传输各种数据是正交的（见4.2节）。对设备访问的同意主要
   是保护用户的隐私免受恶意站点的影响。通过
   对比，同意派网络流量大约是防止
   用户的浏览器被用来攻击它的本地网络。因此，
   即使网站根本无法
   访问摄像头和麦克风（因此也是WebSockets的同意
   机制），我们需要确保通信同意，同样我们需要关注
   访问用户的摄像头和麦克风的网站，即使数据是将于2014年7月26日抵制Rescorla [第7页]


Internet-Draft WebRTC Security 2018年1月
 
   通过传统的基于HTTP的网络机制
   （如HTTP POST）发送回网站。4.1.1。屏幕共享带来的威胁 
   除摄像头和麦克风访问外，还需要
   屏幕和/或应用程序共享功能。不幸的是，
   与
   摄像头和麦克风访问相比，这种功能的安全隐患对于用户来说更难以直观地分析。
   （请参阅http://lists.w3.org/Archives/Public/public-webrtc/2013Mar/0024.html 
   进行全面分析。）
   最明显的威胁只是“过度分享”。也就是说，




   当用户实际上正在
   共享应用程序时，用户可能认为他们正在共享窗口，或者可能忘记他们正在共享他们的整个
   屏幕，图标，通知等等。这已经成为
   现有屏幕共享技术的一个问题，如果
   部分受信任的站点负责要求
   共享资源而不是让用户提出它，则会更糟糕。

   不太明显的威胁涉及屏幕共享对
   Web安全模型的影响。同源策略的一个关键部分是
   来自站点A的HTML或JS可以引用站点B中的内容并导致
   浏览器加载它，但是（除非明确允许）看不到
   结果。但是，如果来自站点的Web应用程序屏幕
   共享浏览器，则会违反该不变量，
   从而导致严重的安全后果。例如，攻击者网站可能会请求
   屏幕共享，然后
   使用屏幕共享来快速打开用户银行或网络邮件帐户的新窗口，以读取生成的
   显示内容。更复杂的攻击将打开
   一个站点的源视图窗口，并使用屏幕共享结果来
   查看反跨站点请求伪造令牌。

   这些威胁表明，
   与访问摄像头或麦克风相比，屏幕/应用程序共享可能需要更高级别的用户同意。

4.1.2。调用方案和用户期望
 
   尽管可能存在大量可能的调用方案，但
   本节中讨论的方案说明
   了识别相关同意范围的许多困难。
   4.1.2.1。专用呼叫服务 
   我们考虑的第一个方案是专用呼叫服务。在
   这种情况下，用户与呼叫站点有关系并
   反复对其进行呼叫。很可能不是必须
   允许用户想要给予Rescorla Expires 2018年7月26日的每次通话[Page 8] Internet-Draft WebRTC Security 2018年1月







   呼叫服务长期访问摄像头和麦克风。这
   自然适合于长期同意机制（例如，安装
   app store“应用程序”以指示对呼叫
   服务的许可。）专用呼叫服务的变体是游戏
   站点（例如，扑克站点）。提供专用的呼叫服务，
   允许玩家互相呼叫。

   对于用户可以使用相同服务与
   许多不同的人交谈的任何类型的服务，存在关于
   用户是否可以知道他们正在与谁交谈的问题。如果我授权
   呼叫服务A代表我拨打电话，那么我是隐含的
   授予它权限，以便在任何时候发生错误。这
   表明另一个同意模型，其中一个站点被授权
   拨打电话，但仅限于某些目标实体（通过
   第4.3.2节，特别是
   第4.3.2.3 节中描述的媒体平面加密机制识别。）请注意这里的同意问题与
   同伴身份的问题有关但不同：我可能
   愿意允许呼叫站点一般
   代表我发起呼叫但仍然通过该站点进行一些呼叫，我可以确定
   该站点没有收听。4.1.2.2。调用 
   您正在访问的站点另一个简单的场景是调用您实际访问的站点。



   这里的范例是“点击这里与
   代表交谈”窗口，这些窗口出现在许多购物网站上。在这种
   情况下，用户期望他们正在呼叫
   他们实际访问的网站。但是，他们不太可能希望
   对此类网站提供普遍同意; 仅仅因为我想要一些
   关于汽车的信息并不意味着我希望汽车制造商
   能够随时激活我的麦克风。因此，这
   表明需要第二个同意机制，我只
   在给定呼叫的持续时间内给予同意。如
   3.1节所述，在设计此接口时必须非常小心
   避免用户只是点击。另请注意，用户
   界面chrome必须清楚地显示显示呼叫
   正在继续的元素，以避免在调用站点
   无限期地离开的情况下发生攻击，但显示另外暗示的Web UI。4.1.3。基于源的安全性 
   现在我们已经看到了另一个用例，我们可以开始推理
   安全性要求。
   如第3.2节所述，Web沙盒的基本单元是
   起源，因此将原始范围同意的范围很自然。
   具体来说，只有来自原点A的脚本才能被允许发起
   通信（因此访问摄像机和麦克风）





Rescorla将于2018年7月26日到期[第9页] 
Internet-Draft WebRTC Security 2018年1月
 
   用户已明确授权访问该来源。这是
   当然，在技术上可能有较粗范围的权限，但
   因为Web模型的作用范围是原产地，这创造了一个艰难
   的不匹配。

   可以说，起源不够精细。考虑
   Alice访问网站并授权其进行单个呼叫的情况。
   如果同意仅以原产地表示，则在将来
   访问该网站（包括通过混搭或广告网络引发的一方），
   该网站可能会破坏Alice的计算机，使用计算机进行虚假
   呼叫等。原则上Alice可以授予然后撤销该
   权限，在实践中权限会累积; 如果我们担心
   这次袭击，还需要其他东西。这类问题有很多
   潜在的对策。

   个人同意

      询问用户是否允许每次通话。

   面向被叫方的同意

      仅允许对给定用户的呼叫。

   加密同意

      仅允许调用给定的一组对等密钥材料或
      加密建立的标识。

   不幸的是，这些方法都不是令人满意的
   案例。如上所述，个人同意将用户的
   批准置于每个呼叫的UI流程中。这不仅会很快
   变得烦人，而且可以训练用户只需单击“确定”，
   此时同意就变得无用了。因此，虽然
   在某些情况下可能需要个人同意，但这不是
   （例如）呼叫服务案例的合适解决方案。当
   必要时，流的用户界面必须精心设计，以
   避免用户盲目点击通过的风险。

   其他两个选项旨在限制对给定
   目标的调用。呼叫站点提供的面向被呼叫者的同意不是
   工作得很好，因为恶意网站可以声称用户正在呼叫
   他选择的任何用户。解决此问题的一个方法是将呼叫与
   加密建立的身份联系起来。虽然不适合所有
   情况，但这种方法对某些人可能有用。如果我们考虑的情况下Rescorla到期2018年7月26日[第10页] Internet草案的WebRTC安全2018年1月 
   的广告，这是不是特别方便，要求
   广告实例对托管网站的iframe只是为了得到
   许可; 更方便的方法是
   将广告商的证书加密地绑定到通信。我们




   仍然将权限绑定到此处，但是对于媒体源（和 - 
   或目标）而不是Web源。
   [ID.ietf-rtcweb-security-arch]描述了促进
   此类同意的机制。

   媒体级加密身份有意义的另一种情况是
   用户确实不信任呼叫站点。例如，我
   可能担心呼叫服务会试图破坏我的
   电脑，但我也希望能够方便地给我的朋友打电话。
   如果同意与特定通信端点相关联，那么我的
   风险是有限的。当然，设计UI有些挑战
   表达这种政策的原始人。
   在多用户呼叫案例中，问题变得更具挑战性。4.1.4。呼叫页面的安全属性 
   基于原始的安全性旨在保护网络攻击者免受攻击。
   但是，我们还必须考虑网络攻击者的情况。
   考虑我已经
   通过具有HTTP方案的来源授予对呼叫服务的许可的情况，例如http：// calling- 
   service.example.com。如果我在不安全的
   网络上使用我的计算机（例如，热点或我自己的家庭无线网络
   不安全），并浏览任何HTTP站点，则攻击者可能会弄错我的
   计算机。攻击如下进行：




   1.我连接到http://anything.example.org/。请注意，此站点
       与呼叫服务无关。

   2.攻击者修改我的HTTP连接以将IFRAME（或
       重定向）注入http://calling-service.example.com 

   3.攻击者显然伪造了响应http：// calling- 
       service.example.com/ to注入JS以启动对自己的呼叫。

   请注意，此攻击不依赖于媒体不安全。
   因为呼叫是针对攻击者的，所以它也被加密。
   而且，不需要立即执行; 攻击者可以
   半永久地“感染”原点（例如，与网络工作者或者
   弹出的窗口隐藏在主窗口下面。）因此
   能够在我离开受感染的网络后很长时间内让我感到烦恼。
   通过允许从通过
   HTTP 获取的页面进行调用来创建此风险。Rescorla将于2018年7月26日到期[第11页] Internet-Draft WebRTC Security 2018年1月 
   即使只能通过HTTPS [RFC2818]站点进行呼叫，如果
   站点嵌入通过
   HTTP或不受信任的方式获取的活动内容（例如，JavaScript）site，因为JavaScript是
   在页面的安全上下文中执行的[更细粒度]。因此，
   允许来自HTTPS源的WebRTC功能也是危险的




   嵌入混合内容。注意：此问题不仅限于
   包含混合内容的PAGES 。如果来自给定来源的页面
   加载了混合内容，则网络攻击者可能会
   半永久地感染浏览器对该来源的概念。



   4.2. 共识通信的验证 
   如第3.3节所述，允许Web应用程序通过浏览器进行不受限制的网络访问会带来计算机被当做攻击平台的风险，而这些计算机对于恶意站点来说可能是不允许访问的，比如，可能因为拓扑限制（例如，有防火墙或NAT后面）。
   为了防止这种形式的攻击以及防范跨协议攻击，要求流量目标明确同意接收相关流量显得至关重要。在确认流量目标接收流量的同意之前，禁止将同意握手以外的流量发送到该端点。

   注意，同意验证不足以防止过度使用网络资源。由于WebRTC允许网站在未经用户同意的情况下在两个浏览器实例之间创建数据流，因此恶意网站可能会通过与另一个用户建立这样一个信道，这样会占用显著数量的用户带宽而不会给自己带来大量成本。但是，实际上有大量的Web站点可以充当数据源，因此攻击者至少可以使用现有Web API来窃取下行链路带宽。但是，这种潜在的DoS向量增强了对WebRTC协议的充分拥塞控制的需求，以确保它们能够满足用户带宽的其他需求。
   4.2.1。ICE 
   验证接收方同意需要某种明确的握手，但方便的是我们已经需要一个以进行NAT转换。ICE [RFC5245]介绍了一种握手方法，旨在验证接收元素是否希望从发送方接收流量。它重要的是要记住启动ICE的网站被
   认为是恶意的; 为了使握手安全，
   接收元件必须证明
   对站点不可用的某些值的接收/知识（从而防止站点伪造
   响应）。为了通过ICE实现这一目标，STUN 
   事务ID必须由浏览器生成，并且不得
   通过诊断接口提供给启动脚本。Rescorla将于2018年7月26日到期[第12页] Internet-Draft WebRTC Security 2018年1月 
   验证接收者同意还需要验证接收者是否需要




   接收来自特定发件人的流量，此时; 对于
   例如恶意网站可能只是试图ICE已知的服务器上，
   使用ICE的其他会议。ICE 
   也通过使用STUN凭证作为每会话共享
   密钥的形式提供此验证。这些凭证对于Web应用程序是已知的，但是
   STUN接收元素也需要知道并使用它们
   才有用。

   还需要一些机制让浏览器验证
   流量的目标是否继续希望接收它。因为
   ICE keepalives是适应症，他们不会在这里工作。[RFC7675] 
   描述了提供同意新鲜度的机制。

4.2.2。掩蔽
 
   一旦核实同意，仍然存在一些关于
   误解攻击的担忧，正如Huang等[huang-w2sp]所述。
   在使用TCP的
   情况下，由于可能存在透明代理，风险很大，因此如果要使用TCP，
   则必须采用WebSockets样式屏蔽。

   由于DTLS（具有TLS 
   1.1 所需的反选择明文机制）不允许攻击者生成可预测的密文，
   因此不需要屏蔽在DTLS上运行的协议（例如
   ，基于DTLS的SCTP，基于DTLS的UDP等）。

   请注意，攻击者原则上可以对SRTP施加一些控制
   通过结合使用WebAudio API和非常
   严格的时序控制来实现数据包。这里的主要风险似乎是
   通过TURN TCP 运送SRTP。但是，由于SRTP数据包具有极其
   特殊的数据包标头，因此除了最具
   侵略性的中介之外，任何人都不会混淆于认为
   正在使用另一个应用程序层协议。4.2.3。向后兼容性 
   使用ICE的要求限制了与传统非ICE 
   客户端的兼容性。完全取消
   某些检查的要求似乎不安全。所有建议的检查都有一个共同特征，即
   浏览器向候选流量接收者发送一些消息



   拒绝发送其他流量，直到该消息被回复。
   必须以这样的方式生成消息/回复对：
   控制Web应用程序的攻击者不能伪造它们，
   通常是通过使消息包含必须
   合并的某些秘密值（例如，回显，散列等）。
   此角色的非ICE 候选人（在遗留端点具有
   公共地址的情况下）包括：Rescorla Expires 2018年7月26日[第13页] Internet-Draft WebRTC Security 2018年1月 
   o STUN不使用ICE进行检查（即非RTC-web端点设置
      STUN响应器。）





   o使用或RTCP作为隐式可达性检查。

   在RTCP方法中，允许WebRTC端点
   在接收同意之前发送有限数量的RTP数据包。这
   允许短暂的攻击窗口。此外，一些传统端点
   不支持RTCP，因此对于
   此类端点而言，这是一种更昂贵的解决方案，为此可能更容易实现ICE。
   出于这两个原因，基于RTCP的方法似乎并未
   令人满意地解决安全问题。

   在STUN方法中，WebRTC端点能够验证
   收件人是否正在运行某种STUN端点，但除非STUN
   响应者与ICE用户名/密码建立
   系统集成，WebRTC端点无法验证收件人是否同意
   此特定呼叫。如果现有STUN 
   服务器在无法处理
   基于带宽的攻击的地址上运行，则这可能是一个问题。因此，这种方法似乎也不
   令人满意。

   如果系统紧密集成（即，STUN端点
   以使用ICE凭证进行身份验证的响应进行响应），则此
   问题不存在。然而，这样的设计非常接近
   ICE-Lite实现（实际上，可以说是一个）。中间
   方法是使用STUN扩展指示一个
   正在响应WebRTC检查，但没有
   根据ICE凭据计算完整性检查。这将允许使用独立的
   STUN服务器，而不会有将它们与传统STUN 
   服务器混淆的风险。如果需要非ICE传统解决方案，那么这
   可能是最佳选择。

   一旦初步同意得到验证，我们还需要验证继续
   同意，以避免两个人短暂共享
   IP的攻击（例如，在网吧中的NAT后面）并且攻击者安排
   大量不可阻挡的流量到然后
   离开网络。这里适当的技术非常相似
   那些获得初步同意的人可能会因为
   威胁不那么严重而变弱。4.2.4。IP位置隐私 
   请注意，一旦被叫方发送其ICE候选者，
   呼叫者就会获知被叫方的IP地址。被叫方的服务器
   反身地址显示了有关被叫方
   位置的大量信息。为了避免跟踪，实现可能希望
   抑制ICE协商的开始直到被呼叫者已经应答。Rescorla将于2018年7月26日到期[第14页] Internet-Draft WebRTC Security 2018 
   年1月此外，任何一方都可能希望完全隐藏其位置







   通过TURN服务器强制所有流量。

   在普通操作中，网站会学习浏览器的IP地址，
   但可能会通过Tor 
   [http://www.torproject.org]或VPN 等机制隐藏。但是，由于站点可以
   使浏览器提供IP地址，因此
   即使
   用户位于掩盖其IP地址的VPN后面，也可以为站点提供了解用户网络环境的机制。
   如果
   用户使用特定类型的VPN，特别是面向隐私的
   系统（如Tor），实现可能希望提供抑制所有非VPN候选者的设置。4.3。通信安全 
   最后，我们考虑SIP世界熟悉的问题：



   通信安全。出于显而易见的原因，
   通信方必须能够建立一个
   对消息恢复和消息修改都是安全的信道。（有关
   详细信息，请参阅[RFC5479]。）必须为
   数据和语音/视频提供此服务。理想情况下
   ，两种类型的内容都将使用相同的安全机制。提供此
   服务的技术（例如，SRTP [RFC3711]，DTLS [RFC6347]和DTLS-SRTP 
   [RFC5763]）已被充分理解。但是，我们必须
   在WebRTC上下文中检查此技术，其中威胁模型有些
   不同。

   一般而言，重要的是要理解与传统的不同
   SIP代理，呼叫服务（即Web服务器）
   不仅控制通信端点之间的通道，还控制
   在用户浏览器上运行的应用程序。虽然原则
   上浏览器可以将呼叫服务从循环中删除
   并直接呈现可信信息（并且可能获得同意），但
   现代浏览器中的实践是尽可能避免这种情况。
   需要用户同意特定
   行动的“ 流动”模式对话特别不受欢迎，因为人为因素研究
   表明，除非它们具有极强的侵入性，否则用户只需
   在没有实际有意识地同意的情况下同意这些对话。
   [阿巴特-rtcweb]。因此，几乎所有的UI都必须
   由浏览器呈现，但是在调用服务的控制下。
   这可能包括对等方的身份信息，
   毕竟，这些信息仅在某些呼叫服务的上下文中有意义。

   这种限制并不意味着防止呼叫
   服务的攻击完全没有希望。但是，我们需要区分
   两类攻击：

   调用服务的回顾性妥协。Rescorla将于2018年7月26日到期[第15页] Internet-Draft WebRTC Security 2018年1月 
      呼叫服务在通话期间是非恶意的，但




      随后被攻陷并希望
   通过呼叫服务来攻击较旧的呼叫
      （通常称为“被动攻击”）
呼叫中的攻击。

      呼叫服务在其希望
      攻击的呼叫期间受到危害（通常称为“主动攻击”）。
   使用第4.3.1节中讨论的技术可以

   提供针对前一类攻击的安全性。但是，
   通过安装
   MITM攻击或完全转移它们
   来防止可信但恶意的呼叫服务主动攻击用户的呼叫是极其困难的。（请注意，
   如果与网络通信进行通信，此攻击同样适用于网络攻击者
   呼叫服务不安全。）我们讨论了一些可能的
   方法以及它们在
   第4.3.2节中可能不切实际的原因。4.3.1。保护免受追溯 
   性攻击在回顾性攻击中，呼叫服务
   在呼叫期间没有妥协，但攻击者随后想要恢复
   呼叫内容。我们假设攻击者可以访问
   受保护的媒体流，并且可以完全控制
   呼叫服务。
   如果呼叫服务可以访问流量密钥材料（如
   SDES [RFC4568]），那么追溯性攻击是微不足道的。这种形式
   的攻击在Web上下文中尤其严重，因为它是




   Web服务中的标准实践，用于执行大量日志记录和
   监视。因此，很可能如果流量密钥是
   任何HTTP请求的一部分，则它将被记录在某处，从而受到
   后续的损害。正是这种考虑使得
   基于公钥的自动密钥交换机制成为
   WebRTC的必要条件（这对于任何通信安全系统都是一个好主意）
   ，这种机制应该提供完美的前向保密（PFS）。所述
   信令信道/主叫服务可以被用于验证此
   机制。

   此外，如果使用端到端密钥，系统绝不能
   提供任何API来提取长期密钥材料或
   直接访问任何存储的流量密钥。否则，
   随后攻击服务的攻击者可能能够使用
   这些API来恢复流量密钥，从而危及
   流量。Rescorla将于2018年7月26日到期[第16页] Internet-Draft WebRTC Security 2018年1月4.3.2。防止呼叫 
   中的攻击在呼叫期间防止攻击是一个更难的
   主张。即使调用服务无法直接访问
   密钥资料（如上一节所述），它也可以
   简单地在连接上发起中间人攻击，告诉






   爱丽丝，她正在呼叫鲍勃和鲍勃他正在呼叫爱丽丝，而
   实际上呼叫服务充当呼叫桥并
   捕获所有流量。防止这种形式的攻击
   需要对远程端点进行积极认证，例如
   明确的带外密钥验证（例如，通过指纹）或
   第三方身份服务，如
   [ID.ietf-rtcweb-security-arch中所述] ]。4.3.2.1。关键连续性 
   一种自然的方法是使用“密钥连续性”。虽然恶意
   呼叫服务可以向用户显示它选择的任何身份，但它
   不能生成映射到给定公钥的私钥。从而，



   浏览器可以记录给定用户的公钥，并
   在用户的密钥更改时生成警报。SSH [RFC4251] 
   使用类似的技术。（请注意，
   在每次调用时都需要避免明确的用户同意，这就要求浏览器需要立即
   手动检查对等方的密钥）。

   不幸的是，这种关键的连续性机制
   在WebRTC上下文中没那么有用。首先，WebRTC 
   （以及任何Web应用程序）的许多优点是它不受特定
   客户端软件的约束。因此，
   对于用户来说，在不同的计算机上使用多个浏览器不仅是可能的而且是常规的
   当然，有不同的密钥材料（SACRED [RFC3760] 
   尽管如此。）因此，用户经常会收到关键
   错配的警报，这些错误实际上是完全合法的，结果
   是他们只需点击一下即可接受培训。众所周知
   ，用户通常会点击更严重的警告
   [cranor-wolf]，任何关键连续性
   机制似乎都不太可能有效而不是简单烦人。

   而且，甚至绕过这种机制也是微不足道的。
   回想一下，与SSH的情况不同，浏览器永远不会直接
   从用户获取对等方的身份。相反，它由提供
   呼叫服务。即使启用这种类型的机制也
   需要API来允许调用服务告诉浏览器“这
   是对用户X的调用”。所有呼叫服务需要做的是避免
   触发密钥连续性警告，告诉浏览器“这
   是对用户Y的调用”，其中Y接近X.即使用户
   实际检查对方的名字（全部可用）证据
   表明不太可能），这将要求（a）浏览器信任Rescorla Expires 2018年7月26日[...] Internet-Draft WebRTC Security 2018年1月 
   UI提供名称和（b）用户不要被类似的愚弄




   出现的名字。4.3.2.2。短认证字符串 
   ZRTP [RFC6189]使用
   从密钥协商协议派生的“短认证字符串”（SAS）。该SAS旨在
   由用户进行比较（例如，通过语音信道朗读或
   通过带外信道传输），如果
   双方确认，则排除MITM攻击。目的是使用SAS 
   一次，然后使用密钥连续性（尽管与
   上面讨论的机制不同）。
   不幸的是，SAS没有为
   受损的呼叫服务问题提供实用的解决方案。“语音转换”




   系统，它修改一个扬声器的声音，使其听起来像
   另一个扬声器，是一个活跃的研究领域。
   在很多情况下，这些系统已经
   足够愚弄自动识别系统[farus-conversion]和人类[kain-conversion]，并且
   当然可能在将来有所改进，特别是在
   用户想要上传的环境中随着电话。
   因此，即使SAS今天有效，也可能不会那么
   长。

   此外，尚不清楚用户是否会实际使用SAS。正如
   上面所讨论的，浏览器UI约束排除需要
   之前完成呼叫SAS交换，所以它必须是
   自主性; 最多浏览器将提供一些
   尚未检查SAS的UI指示符。然而，众所周知，
   当面对可选的安全机制时，许多用户只是
   忽略它们[whitten-johnny]。

   一旦用户检查了SAS一次，就需要密钥连续性以
   避免他们需要在每次呼叫时检查它。但是，
   由于第4.3.2.1节中所述的原因，这是有问题的。原则
   上，当然可以渲染一个不同的UI元素来指示
   调用正在使用未经验证的一组密钥材料
   （回想一下，攻击者只能提供一个稍微不同的名称
   因此，攻击显示与调用新设备或
   之前未调用的人相同的UI ）但实际上，
   即使在
   混合内容警告的更加严峻的情况下，用户也会忽略这些指标。4.3.2.3。第三方身份 
   提供通信身份的传统方法
   当然是具有一些第三方身份系统（例如，PKI）来
   验证端点。这种机制已被证明是过于Rescorla到期2018年7月26日[第18页] Internet草案的WebRTC安全2018年1月 
   繁琐供一般用户的使用（用近过于繁琐







   管理员）。然而，
   最近开发了新一代基于Web的身份
   提供商（BrowserID，Federated Google Login，Facebook Connect，OAuth，OpenID，WebFinger），并使用Web 
   技术提供轻量级（从用户的角度来看）
   第三方认证交易。可以使用
   这种类型的系统来验证WebRTC呼叫，将它们链接到
   现有用户的身份概念（例如，Facebook邻接）。
   具体而言，第三方身份系统用于将
   用户的身份绑定到加密密钥材料，然后用于
   验证呼叫端点。经过身份验证的呼叫
   以这种方式即使对于
   主叫站点的主动MITM攻击也是自然抗性的。

   请注意，有一种特殊情况，其中PKI样式的证书
   确实提供了实用的解决方案：从最终用户到大型站点的呼叫。
   例如，如果您打电话给Amazon.com，那么亚马逊可以
   轻松获得证书来验证他们的媒体流量，就像
   他们获得一个验证他们的网络流量一样。
   在呼叫站点
   和媒体对等体是同一个的情况下，这不提供额外的安全价值，但
   在第三方（例如，广告网络或零售商）安排
   呼叫但不参与呼叫的情况下可能有用。他们。

4.3.2.4。页面访问媒体
 
   识别远媒体端点的身份是
   提供媒体安全性的必要条件，但不是充分条件。在WebRTC中，
   媒体流被渲染为HTML5 MediaStream，可以
   由调用站点操纵。显然，如果站点可以修改
   或查看媒体，那么用户无法获得
   他们期望能够对其
   对等方进行身份验证的保证级别。在许多情况下，这是可以接受的，因为用户重视
   基于站点的特殊效果，而不是来自站点的完全安全性。
   但是，也有用户希望知道该网站的情况
   不能干涉。为了促进这一点，有必要
   提供一些功能，使网站可以可验证地放弃
   对媒体流的访问。必须可以从
   本地侧和远程侧进行此验证。即，我必须能够验证
   我呼叫的人是否采用了安全媒体模式。为了
   实现这一点，有必要
   将本地媒体访问策略的指示加密地绑定到
   前面部分中详述的加密认证过程中。Rescorla将于2018年7月26日到期[第19页] Internet-Draft WebRTC Security 2018年1月




4.3.3。恶意同行
 
   我们通常不会试图阻止的一类攻击是
   恶意同行。例如，无论
   您采用何种保密措施，您正在
   与之交谈的人都可以记录呼叫并将其发布到互联网上。同样，我们也不会试图
   阻止他们使用语音或视频处理技术
   隐藏或改变其外观。虽然
   确实存在技术（DRM等）以试图解决这些问题，但它们通常
   与开放系统不兼容，并且WebRTC不解决它们。

   同样，我们不会试图阻止恶作剧电话或其他
   不必要的电话。通常，这是在调用的范围内
   网站，虽然因为WebRTC确实提供了某种形式的强
   身份验证，这可能有助于防范此类
   攻击。4.4。隐私考虑因素4.4.1。匿名呼叫的相关性 
   虽然持久端点标识符可以是一个有用的安全
   功能（参见第4.3.2.1节，它们也可以代表
   用户希望匿名的设置中的隐私威胁.WebRTC提供了
   许多可能的持久标识符，如DTLS证书
   （如果它们在连接之间重用）和RTCP 
   CNAMES （如果根据[RFC6222]生成而不是[RFC7022]的隐私保护
   模式）。为了防止这种类型的关联，





   浏览器需要提供重置这些标识符的机制（例如，
   与cookie的生命周期相同）。此外，API应该提供
   允许用于匿名呼叫的站点强制创建
   新标识符的机制。此外，IP地址可以是
   呼叫链接的来源[ID.ietf-rtcweb-ip-handling] 4.4.2。浏览器指纹识别 
   任何新的API功能都会增加浏览器指纹识别的风险，
   WebRTC也不例外。具体而言，站点可以使用
   特定设备的存在或不存在作为浏览器指纹。通常，
   API需要在功能和
   增量指纹风险之间进行平衡。




5.安全注意事项
 
   整个文档都是关于安全性的。Rescorla将于2018年7月26日到期[第20页] 互联网草案WebRTC安全2018年1月6.致谢 
   Bernard Aboba，Harald Alvestrand，Dan Druta，Cullen Jennings，Alan 
   Johnston，Hadriel Kaplan（S 4.2.1），Matthew Kaufman，Martin Thomson，
   Magnus Westerlund。7. IANA注意事项 
   没有IANA注意事项。8.自-04以来的变化 
   o用WebRTC替换RTCWEB和RTC-Web，除非在提及
      IETF WG 
   o删除了对IFRAMEd广告案例的讨论时，因为我们













      决定不特别对待它。

   o添加了隐私部分注意事项部分。

   o对SAS部分进行了重大编辑，以反映Alan Johnston的
      评论。

   o如果IP位置隐私和Tor增加了一些讨论。

   o更新了“通信同意”部分以重新更新草稿
      。

   o添加了关于“恶意同行”的部分。

   o添加了描述屏幕共享威胁的部分。

   o各种编辑修改。9.参考文献9.1。规范性参考文献 
   [RFC2119] Bradner，S。，“用于RFC指示
              需求水平的关键词”，BCP 14，RFC 2119，





              DOI 10.17487 / RFC2119，1997年3月，<https：//www.rfc- 
              editor.org/info/rfc2119>。9.2。信息参考 
   [abarth-rtcweb] 
              Barth，A。，“提示用户安全失败”，RTC- 
              Web Workshop，2010年9月.Rescorla将于2018年7月26日到期[第21页] Internet-Draft WebRTC Security 2018年1月 
   [CORS]面包车Kesteren，A。，“Cross-Origin Resource Sharing”，
              2014 年1月。
   [cranor-wolf] 
              Sunshine，J.，Egelman，S.，Almuhimedi，H.，Atri，N。和
              L. cranor，“Crying Wolf： SSL警告的实证研究








              有效性“，第18届USENIX安全
              研讨会论文集，2009年，2009年8月。

   [farus-conversion] 
              Farrus，M.，Erro，D。和J. Hernando，”演讲者
              识别语音转换的稳健性“，2008年1月。

   [更好-grained] 
              巴特，A和C.杰克逊“谨防细粒度的
              起源”，w2SP，2008年，2008年7月

   [黄w2sp] 
              黄，LS，陈，E.，巴特，A.，Rescorla， E.和C. 
              杰克逊，“为自己寻求乐趣和利润”，W2SP，
              2011年，2011年5月。

   [ID.ietf-rtcweb-ip-handling]
              Uberti，J。和G. Shieh，“WebRTC IP地址处理
              要求”，draft-ietf-rtcweb-ip-handling-04（
              正在进行中），2017年7月。

   [ID.ietf-rtcweb-overview] 
              Alvestrand，H。 ，“概述：
              基于浏览器的应用程序的实时协议”，draft-ietf-rtcweb-overview-19 
              （正在进行中），2017年11月。

   [ID.ietf-rtcweb-security-arch] 
              Rescorla，E。，“WebRTC安全架构“，draft- 
              ietf-rtcweb-security-arch-13（正在进行中），2017年10月。

   [kain-conversion] 
              Kain，A。和M. Macon，”设计和评估一个声音
              基于谱包络映射
              和残差预测的转换算法“，ICASSP会议论文集，
              2001年5 月，2001年5月。

   [RFC2818] Rescorla，E。，”HTTP Over TLS“，RFC 2818，
              DOI 10.17487 / RFC2818，2000年5月，<https： //www.rfc- 
              editor.org/info/rfc2818> .Rescorla 将于2018年7月26日到期[第22页] 互联网草案WebRTC安全2018年1月 
   [RFC3261] Rosenberg，J.，Schulzrinne，H.，Camarillo，G。， Johnston，
              A.，Peterson，J.，Sparks，R.，Handley，M。和E. 
              Schooler，“SIP：Session Initiation Protocol”，RFC 3261，




              DOI 10.17487 / RFC3261，2002年6月，<https：//www.rfc- 
              editor.org/info/rfc3261>。

   [RFC3552] Rescorla，E。和B. Korver，“ 
              关于安全考虑的RFC 文本编写指南”，BCP 72，RFC 3552，
              DOI 10.17487 / RFC3552，2003年7月，<https：//www.rfc- 
              editor.org/信息/ rfc3552>。

   [RFC3711] Baugher，M.，McGrew，D.，Naslund，M.，Carrara，E。和K. 
              Norrman，“安全实时传输协议（SRTP）”，
              RFC 3711，DOI 10.17487 / RFC3711，March 2004年，
              <https://www.rfc-editor.org/info/rfc3711>。

   [RFC3760] Gustafson，D.，Just，M。和M. Nystrom，“安全地
              可用凭证（SACRED） - 凭证服务器
              框架“，RFC 3760，DOI 10.17487 / RFC3760，2004年4月，
              <https://www.rfc-editor.org/info/rfc3760>。

   [RFC4251] Ylonen，T。和C. Lonvick，Ed。，“Secure Shell（SSH）
              Protocol Architecture”，RFC 4251，DOI 10.17487 / RFC4251，
              2006年1月，<https://www.rfc-editor.org/info/rfc4251>。

   [RFC4568] Andreasen， F.，Baugher，M。和D. Wing，“会话
              描述协议（SDP）媒体
              流的安全描述”，RFC 4568，DOI 10.17487 / RFC4568，2006年7月，
              <https://www.rfc-editor.org /信息/ rfc4568>。

   [RFC5245] Rosenberg，J。，“交互式连接建立
              （ICE）：
              用于提供/应答协议的网络地址转换器（NAT）遍历的协议”，RFC 5245，
              DOI 10.17487 / RFC5245，2010年4月，<https：// www .rfc- 
              editor.org/info/rfc5245>。

   [RFC5479] Wing，D.，Ed。，Fries，S.，Tschofenig，H。和F. Audet，
              “媒体安全管理
              协议的要求和分析”，RFC 5479，DOI 10.17487 / RFC5479，2009年4月，
              <https ：//www.rfc-editor.org/info/rfc5479>。

   [RFC5763] Fischl，J.，Tschofenig，H。和E. Rescorla，“
              （SRTP）安全上下文使用数据报传输层
              安全性（DTLS）“，RFC 5763，DOI 10.17487 / RFC5763，
              2010年5 月，<https://www.rfc-editor.org/info/rfc5763> .Rescorla 将于2018年7月26日到期[Page 23] Internet-Draft WebRTC Security 2018年1月号 
   [RFC6189] Zimmermann，P.，Johnston，A.，Ed。和J. Callas，“ZRTP：
              Unicast Secure RTP的媒体路径密钥协议”，
              RFC 6189，DOI 10.17487 / RFC6189，2011年4月，
              <https://www.rfc-editor.org/info/rfc6189>。
   [RFC6222] Begen，A.，Perkins，C。和D. Wing，“指南





              选择RTP控制协议（RTCP）规范名称
              （CNAME）“，RFC 6222，DOI 10.17487 / RFC6222，2011年4月，
              <https://www.rfc-editor.org/info/rfc6222>。

   [RFC6347] Rescorla，E。和N. Modadugu，“数据报传输层
              安全版本1.2”，RFC 6347，DOI 10.17487 / RFC6347，
              2012年1月，<https://www.rfc-editor.org/info/rfc6347>。

   [RFC6454] Barth，A。 ， “网络起源观”，RFC 6454，
              DOI 10.17487 / RFC6454，2011年12月，<HTTPS：//www.rfc- 
              。editor.org/info/rfc6454> 

   [RFC6455]的Fette，I。和A.尼科夫，“ WebSocket协议“，
              RFC 6455，DOI 10.17487 / RFC6455，2011年12月，
              <https://www.rfc-editor.org/info/rfc6455>。

   [RFC7022] Begen，A.，Perkins，C.，Wing，D。和E. Rescorla，
              “选择RTP控制协议（RTCP）
              规范名称（CNAME）的指南”，RFC 7022，DOI 10.17487 / RFC7022，
              2013年9月，<https://www.rfc-editor.org/info/rfc7022>。

   [RFC7675] Perumal，M.，Wing，D.，Ravindranath，R.，Reddy，T。和M. 
              Thomson，“Session Traversal Utilities for NAT（STUN）用法
              同意新鲜度”，RFC 7675，DOI 10.17487 / RFC7675 ，
              2015年10月，<https://www.rfc-editor.org/info/rfc7675>。

   [SWF] Adob​​e，“SWF文件格式规范版本19”，

   [whitten-johnny] 
              Whitten，A。和J. Tygar，“为什么Johnny无法加密：
              PGP 5.0的可用性评估”，第8届
              USENIX安全研讨会论文集，1999年，1999年8月。作者的地址Rescorla将于7月26日到期， 2018年[第24页] 互联网草案WebRTC安全2018年1月 
   Eric Rescorla 
   RTFM，
   Inc。2064 Edgewood Drive 
   Palo Alto，CA 94303 
   USA 
   电话：+1 650 678 2350 
   电子邮件：ekr@rtfm.com Rescorla将于2018年7月26日到期