Web实时通信 E. Rescorla 
互联网草案 去读那些**的手册
预期状态：将会标准化的草案 2018年1月22日
到期日：2018年7月26日
                   Web实时通信的安全注意事项                 draft-ietf-rtcweb-security-10
摘要 

   WebRTC是一个协议套件，用于可以在浏览器中部署的实时应用程序-“Web上的实时通信”。
   本文档定义了WebRTC威胁模型，并分析了该模型中WebRTC的安全威胁。

WebRTC安全互联网草案 2018年1月
 
   本文档可能包含IETF文档或IETF贡献的材料，这些材料在2008年11月10日之前发 布或公开。控制某些文档材料版权的人员此可能还未授予IETF Trust在IETF标准流程之外修改此类材料的许可。
   如果没有从版权控制者那里获得足够的许可，本文档不得在IETF标准流程之外进行修改，并且其衍生作品可能不允许在IETF标准流程之外创建，除了将其格式化以便作为RFC发布或将其翻译成非英语语言。

   1.简介 
   Web上的实时通信（RTCWEB）工作组的任务是标准化Web浏览器之间实时通信的协议，通常称为“WebRTC”[ID.ietf-rtcweb-overview]。WebRTC技术的主要用例是实时音频/视频呼叫，Web会议和直接数据传输。与大多数传统的实时系统不同，（例如，基于SIP的[RFC3261]软电话）WebRTC通信由某些Web服务器直接控制。一个简单的案例如下所示。

   在图1所示的系统中，Alice和Bob都有支持WebRTC的浏览器和他们访问一些运营
   呼叫服务的Web服务器。他们的每个浏览器都提供标准化JavaScript的API（实现为浏览器内置函数），Web服务器使用这些API来建立Alice和Bob之间的呼叫。
   Web服务器还用作在浏览器之间传输控制消息的信令通道。虽然该系统在
   拓扑上类似于传统的基于SIP的系统（Web服务器提供信令服务，浏览器提供
   软电话），但控制已转移到中央Web服务器; 浏览器只是简单地提供了呼叫服务使用的API点。如对于任何Web应用程序，Web服务器可以在服务器和浏览器的JavaScript之间移动逻辑，但不论代码在何处执行，它最终都在服务器的控制之下。

   显而易见，这种类型的系统暴露出了超越传统VoIP系统的新的安全挑战。在某些时候，它需要与恶意呼叫服务相抗衡。例如，如果调用的服务可能会导致浏览器拨打电话，那么在任何时候它选择的任何被叫方这个工具都可以在用户不知情的情况下窃听用户的计算机，这只需要通过发出呼叫的一些记录服务。更危险的是，如果暴露的API允许服务器指示浏览器发送任意内容，它们可以用这种漏洞绕过防火墙或挂载拒绝服务攻击。任何成功的系统都需要抵御这种和其他网络攻击。

   配套文档[ID.ietf-rtcweb-security-arch]描述了
   旨在解决本
   文档中提出的问题的安全体系结构。
   2.术语 
   关键词“必须”，“必须”，“必须”，“应该”，“不应该”，
   “应该”，“不应该”，“推荐”，“可以”和“可选”本
   文档的解释如RFC 2119 [RFC2119]中所述。
   3.浏览器威胁模型
   WebRTC的安全要求直接遵循保护用户的浏览器工作要求。Huang等人[huang-w2sp]把核心浏览器安全保障总结如下：

      用户可以安全地访问任意网站并执行这些网站提供的脚本。

   重要的是要意识到这包括任意执行恶意脚本的站点。这个要求的动机很简单：
   攻击者引导用户转移到他们选择的站点是容易实现的。
   例如，攻击者可以购买显示广告，该广告将用户（自动地或通过用户点击）引导到他们的含有恶意脚本的站点，此时浏览器将执行攻击脚本。
   因此，只有查看任意恶意页面是安全的才是重要的。当然，浏览器不可避免地存在BUG使得它们达不到此目标，但任何新的WebRTC系统功能都必须以满足此标准来设计。
   本节的其余部分提供了更多的关于现有Web安全模型的背景知识。
   
   在这个模型中，浏览器从用户的角度上和在某种程度上从服务器角度充当可信计算基础（TCB）。虽然服务器提供的HTML和JavaScript（JS）可以使浏览器执行各种操作，但这些脚本在沙箱中运行，将它们与用户的计算机和其他服务器都相互隔离，详细如下所述。

   传统上，我们既指能够诱导用户访问恶意网站但不能控制网络的Web攻击者，也指能够控制用户网络的网络攻击者。网络攻击者对应[RFC3552]“Internet威胁模型”。请注意，对于非HTTPS流量，网络攻击者也是Web攻击者，因为它可以像任何非HTTPS站点一样注入流量。因此，在分析HTTP连接时，我们必须假设
   流量在流向攻击者。
   3.1 访问本地资源 
   虽然浏览器可以访问本地资源，如密钥，文件，摄像头和麦克风，但它严格限制或
   禁止Web服务器访问这些相同的资源。例如，尽管有可能产生一个HTML表单，将会   允许文件上传，但是脚本不能未经用户同意这样做，并且事实上甚至不能指定一个特定的文件（例如，/etc/passwd文件）; 用户必须明确选择该文件并同意上传。
   [注意：在很多情况下，浏览器是明确设计避免对话框的语义为“点击这里让自己疯掉”，因为广泛的研究表明用户在这种情况下很容易选择同意。] 

   类似地，虽然Flash程序（SWF）[SWF]可以访问摄像头和麦克风，但他们明确要求用户同意该访问权限。此外，某些资源无法通过浏览器访问。例如，没有方法可以直接从脚本运行特定可执行文件（尽管用户可以诱导下载可执行文件并运行它们）。
   3.2. 同源策略 
   许多其他资源可以访问但是是孤立的。例如，虽然允许脚本通过XMLHttpRequest（）API发出HTTP请求，但不允许将这些请求发送到任何服务器，而是仅允许与脚本同源的服务器 [RFC6454]（尽管CORS[CORS]和WebSockets[ RFC6455]提供了一个逃避限制，如下所述。）这个同源策略（SOP）可防止服务器A通过用户的浏览器对服务器B发起攻击，从而保护用户（比如，用户凭据不被滥用）和服务器B（比如，不受DoS攻击）。
   更一般地说，SOP强制每个站点的脚本在他们自己的隔离沙箱中运行。虽然存在允许它们进行交互的技术，但这些交互通常必须是相互共识的（由每个站点）并且仅限于某些通道。例如，同源的多个页面/浏览器窗格可以读取彼此的JS变量，但来自不同来源的页面——甚至来自同一页面上不同来源的iframe——不能读取彼此的JS变量。
   3.3. 绕过SOP：CORS，WebSockets和共识通信
   虽然SOP提供了重要的安全功能，但它也使得编写某些类别的应用程序变得不方便。特别是mash-ups，其中源点A的脚本使用来自源点B的资源，只能通过一定的hackery来实现。
   W3C跨源资源共享（CORS）规范[CORS]是对此需求的响应。在CORS中，当源点A的脚本执行原本禁止的跨源请求时，浏览器会与目标服务器通信以确定是否愿意允许来自A的跨源请求。如果愿意，则浏览器就会允许请求。这种共识验证过程旨在安全地允许跨源请求。

   尽管CORS是设计目的是允许跨源HTTP请求，但是WebSockets [RFC6455]允许跨源建立透明通道。一旦从脚本到站点建立了WebSockets连接，脚本就可以交换它想要交换的任何流量，而不需要将其构建为一系列HTTP请求/响应事务。与CORS一样，WebSockets事务以共识验证阶段开始，以避免允许脚本简单地将任意数据发送到另一个服务器或客户端。

   虽然同意验证在概念上很简单——只需在开始交换真实数据之前进行握手——经验表明设计正确的同意验证系统是具有难度的。特别Huang等人在[huang-w2sp]中已经展示了在现有的Java和Flash共识验证技术以及WebSockets握手的简化版本中的漏洞。
   特别重要的是要警惕交叉协议的攻击，在交叉协议攻击中脚本生成某些非Web协议状态机可接受的流量。为了抵御这种形式的攻击，WebSockets采用了一种掩码技术，旨在将线路上的比特流随机化，从而使生成类似已存在协议的流量变得更加困难。


Internet-Draft WebRTC Security 2018年1月

4. WebRTC应用程序的安全性

4.1.  	访问本地设备
   
	如第一节所述，允许任意站点发起呼叫，这违反了核心web安全保障：如果没有对本地设备的访问限制，任何恶意站点都可能会对用户造成问题。在没有用户的同意的情况下，任何站点都不能向任意位置发起呼叫。这就引发了一个问题：用户同意的范围怎么定义。
   
	用户想要对是否允许呼叫（他的摄像头和麦克风输入被路由到某处）做出明智的决定，他就必须了解请求访问的人或者媒体的去向。如下所述，有两种基本的概念模型。
   
1.您将媒体发送给实体A因为你想与A交流。
2.实体A（例如呼叫服务）请求访问用户的设备，并保证它将媒体转移到实体B（例如您的母亲）
   
	在任何一种情况下，身份都是决定的核心。而且，浏览器连接的一方的身份是所有浏览器都可以执行：如果您正在呼叫A，则A可以简单地将媒体转发给C.同样，如果您授权A 向B发出呼叫，则A可以呼叫C。在任何一种情况下，所有
 浏览器都能够验证并检查控制媒体所在位置的任何人的授权。媒体的目标当然可以宣传安全/隐私政策，但这不是 浏览器可以强制执行的。即便如此，还有各种不同的同意方案可以激发不同的技术同意机制。我们将在下面的部分中讨论这些机制。

   
同意访问本地设备与同意通过网络传输各种数据是正交的（参见4.2节）了解这点很重要。是否允许访问设备主要取决于保护用户的隐私免受恶意站点的影响。通过对比，同意传输网络是用来防止用户浏览器被利用去攻击它本地的网络。因此我们需要确保同意通信即使该站点根本不能接入摄像头和麦克风（websockets同意机制），同样我们需要关注访问用户的摄像头和麦克风的网站，即使数据是
通过传统的基于HTTP的网络机制发送回网站，例如HTTP POST.

4.1.1屏幕共享带来的威胁
  
	除了摄像头和麦克风的访问外，还需要屏幕和应用程序共享功能。不幸的的是，与摄像头和麦克风相比，这种功能的安全隐患对于用户来说更难以直观地分析（具体请参考 http://lists.w3.org/Archives/Public/public-webrtc/2013Mar/0024.html）

   
	
	最明显的威胁就是“过度分享”。也就是说，当用户实际上正在共享应用程序时，用户可能认为他们正在共享窗口或者可能忘记他们正在共享整个屏幕，图标，通知等等。这已经成为现有屏幕共享技术的一个问题，如果部分受信任的站点负责要求
   
   
   
	   
不太明显的威胁是对web安全模型的影响。同源策略的一个关键部分是来自站点A的HTML或JS可以可以引用站点B中的内容并导致浏览器加载它，但是（除非明确允许）看不到结果。但是，如果来自站点的web应用程序屏幕共享浏览器，则会违反该不变量，从而导致严重的安全后果。例如，攻击者网站可能会请求屏幕共享，然后使用屏幕共享来快速打开用户银行或网络邮件账户的新窗口，以读取生产的显示内容。更复杂的攻击将打开一个站点的源视图窗口，并使用屏幕共享结果来查看反跨站点请求伪造令牌。这些威胁表明与访问摄像头或麦克风相比，屏幕、应用程序共享可能需要更高级别的用户同意。

4.1.2.  调用方案和用户期望
   
尽管可能存在大量可能的调用方案，但本节中讨论的方案说明了识别相关同意范围的许多困难。
4.1.2.1.专用呼叫服务
  
我们考虑的第一个方案是专用呼叫服务。在这种情况下，用户与呼叫站点有关系并反复对其进行呼叫。很可能不是必须允许用户想要给予每次通话呼叫服务长期访问摄像头和麦克风。这自然适合于长期同意机制（例如，安装app store“应用程序”以指示对呼叫服务的许可）专用呼叫服务的变体是游戏站点（例如，扑克站点）。提供专用的呼叫服务，允许玩家互相呼叫。

   
对于用户可以使用相同服务与许多不同的人交谈的任何类型的服务，存在关于用户是否可以知道他们正在与谁交谈的问题。如果我授权呼叫服务A代表我拨打电话，那么我是隐含的授予它权限。这表明另一个同意模型，其中一个站点被授权拨打电话，但仅限于某些目标实体（通过4.3.2节，特别是第4.3.2.3节中描述的媒体的平面加密机制识别）请注意这里的同意问题与同伴身份的问题有关但不同：我可能愿意允许呼叫站点代表我发起呼叫，但仍然通过该站点进行一些呼叫，我可以确定该站点没有监听。
4.1.2.2.  调用你正在访问的站点
   

另一个简单的场景是调用您实际访问的站点。这里的范例是“点击这里与代表交谈”窗口，这些窗口出现在许多购物网站上。在这种情况下，用户期望他们正在呼叫他们实际访问的网站。但是，他们不太可能希望对此类网站提供所有同意；仅仅因为我想要一些关于汽车的信息并不意味着我希望汽车制造商能够随时激活我的麦克风。因此，这表明需要第二个同意机制，我只在给定呼叫的持续时间给予同意。如3.1节所述，在设计此接口时必须非常小心以避免用户点击。另外用户界面chrome必须清楚地表明呼叫正在进行，以避免在调用站点无限期地离开但是显示webUI的情况下发生攻击。
4.1.3.  基于源的安全性
   
现在我们已经看到了另一个用力，我们可以推理安全性要求。如第3.2节所述，web沙盒的基本单元是起源，因此将同意范围设置为初始值很自然。具体来说，如果用户已明确授权访问该来源，只有来自原点A的脚本才能被允许发起通信（因此访问摄像头和麦克风）。在技术上可能有较粗略的范围的权限，但因为WEB模型的作用范围是原产地，这创造了一个棘手的不匹配问题。
   
可以说，起源不够精细。考虑Alice访问网站并授权其进行单个呼叫的情况。
如果同意仅以原产地表示，则在将来访问该网站（包括通过混搭或广告网络引发的一方），该网站可能会破坏Alice的计算机，使用计算机进行虚假呼叫等。原则上Alice可以授予然后撤销该权限，在实践中权限会累积; 如果我们担心这次袭击，还需要其他东西。这类问题有很多潜在的对策。
   1）个人同意
      询问用户是否允许每次通话。

   2）面向被叫方的同意

      仅允许对给定用户的呼叫。
   3）加密同意
      
仅允许调用给定的一组对等密钥材料或
加密建立的标识。

   
不幸的是，这些方法都不是令人满意。如上所述，个人同意将用户的批准置于每个呼叫的UI流程中。这不仅会很快变得烦人，而且可以训练用户只需单击“确定”，此时同意就变得无用了。因此，虽然在某些情况下可能需要个人同意，但这不是（例如）呼叫服务案例的合适解决方案。当必要时，流的用户界面必须精心设计，以避免用户盲目点击通过的风险。

  
其他两个选项旨在限制对给定目标的调用。呼叫站点提供的面向被呼叫者的同意不是工作得很好，因为恶意网站可以声称用户正在呼叫他选择的任何用户。解决此问题的一个方法是将呼叫与加密建立的身份联系起来。虽然不适合所有
 情况，但这种方法对某些人可能有用。如果我们考虑的情况下的广告，这不是特别方便，要求广告实例对托管网站的iframe只是为了得到许可; 更方便的方法是
将广告商的证书加密地绑定到通信。我们仍然将权限绑定到此处，但是对于媒体
而不是Web源。[ID.ietf-rtcweb-security-arch]描述了促进此类同意的机制。

   
媒体级加密身份有意义的另一种情况是用户确实不信任呼叫站点。例如，我可能担心呼叫服务会试图破坏我的电脑，但我也希望能够方便地给我的朋友打电话。
如果同意与特定通信端点相关联，那么我的风险是有限的。当然，设计UI有些挑战表达这种政策的原始人。在多用户呼叫案例中，问题变得更具挑战性。
4.1.4.呼叫页面的安全属性
   
基于原始的安全性旨在保护网络攻击者免受攻击。但是，我们还必须考虑网络攻击者的情况。考虑我已经通过具有HTTP方案的来源授予对呼叫服务的许可的情况，例如http：// calling- service.example.com。如果我在不安全的网络上使用我的计算机（例如，热点或我自己的家庭无线网络不安全），并浏览任何HTTP站点，则攻击者可能会弄错我的计算机。攻击如下进行：
   1.我连接到http://anything.example.org/。请注意，此站点
       与呼叫服务无关。

   2.攻击者修改我的HTTP连接以将IFRAME（或
       重定向）注入http://calling-service.example.com 

   3.攻击者显然伪造了响应http：// calling- 
       service.example.com/ to注入JS以启动对自己的呼叫。

  
请注意，此攻击不依赖于媒体不安全。因为呼叫是针对攻击者的，所以它也被加密。而且，不需要立即执行; 攻击者可以半永久地“感染”原点（例如，与网络工作者或者弹出的窗口隐藏在主窗口下面。）因此能够在我离开受感染的网络后很长时间内让我感到烦恼。通过允许从通过HTTP 获取的页面进行调用来创建此风险。
   
即使只能通过HTTPS [RFC2818]站点进行呼叫，如果站点嵌入通过HTTP或不受信任的方式获取的活动内容（例如，JavaScript）site，因为JavaScript是在页面的安全上下文中执行的[更细粒度]。因此，允许来自HTTPS源的WebRTC功能也是危险的嵌入混合内容。注意：此问题不仅限于包含混合内容的PAGES 。如果来自给定来源的页面加载了混合内容，则网络攻击者可能会半永久地感染浏览器对该来源的概念。

   4.2. 共识通信的验证 
   如第3.3节所述，允许Web应用程序通过浏览器进行不受限制的网络访问会带来计算机被当做攻击平台的风险，而这些计算机对于恶意站点来说可能是不允许访问的，比如，可能因为拓扑限制（例如，有防火墙或NAT后面）。
   为了防止这种形式的攻击以及防范跨协议攻击，要求流量目标明确同意接收相关流量显得至关重要。在确认流量目标接收流量的同意之前，禁止将同意握手以外的流量发送到该端点。

   注意，同意验证不足以防止过度使用网络资源。由于WebRTC允许网站在未经用户同意的情况下在两个浏览器实例之间创建数据流，因此恶意网站可能会通过与另一个用户建立这样一个信道，这样会占用显著数量的用户带宽而不会给自己带来大量成本。但是，实际上有大量的Web站点可以充当数据源，因此攻击者至少可以使用现有Web API来窃取下行链路带宽。但是，这种潜在的DoS向量增强了对WebRTC协议的充分拥塞控制的需求，以确保它们能够满足用户带宽的其他需求。
   4.2.1。交互式连接建立 
   验证接收方同意需要某种明确的握手，但方便的是我们已经需要一个以进行NAT转换。
   ICE [RFC5245]介绍了一种握手方法，旨在验证接收元素是否希望从发送方接收流量。重要的是要记住启动ICE的网站是否是假设为恶意的; 为了使握手安全，接收元素必须证明对站点不可用的某些值的接收/知识（从而防止站点伪造响应）。为了通过ICE实现这一目标，STUN事务ID必须由浏览器生成，并且禁止通过诊断接口提供启动脚本。
   验证接收者同意还需要验证接收者是否需要接收来自特定发送者的流量，此时; 例如恶意网站可能只是试图建立ICE到已知的服务器上，使用ICE的其他部分。ICE也通过使用STUN凭证作为每次会话共享密钥的形式提供此验证。这些凭证对于Web应用程序是已知的，但是STUN接收元素也需要知道并使用它们才有奏效。
   还需要一些机制让浏览器验证流量的目标是否继续希望接收它。因为ICE的保活是需要指明的，保活并不能够在这里工作。[RFC7675]描述了提供保活同意的机制。

4.2.2. 掩码
 
   尽管共识同意被核实了，但是仍然存在一些关于误解攻击的担忧，正如Huang等在[huang-w2sp]所述。在使用TCP的情况下，由于可能存在透明代理，风险很大，因此如果要使用TCP，则必须采用WebSockets样式的掩码。

   由于DTLS（具有反选择明文机制的TLS1.1）不允许攻击者生成可预测的密文，因此不需要屏蔽在DTLS上运行的协议（例如，基于DTLS的SCTP，基于DTLS的UDP等）。
   
   注意，攻击者原则上可以对SRTP施加一些控制通过结合使用WebAudio API和非常严格的时序控制来实现封装数据包。这里主要的风险似乎是通过利用TCP来传输SRTP。但是，由于SRTP数据包具有极其特殊的数据包标头，因此除了最具侵略性的中介之外，任何人都不会将这种数据包和正在使用的另一个应用程序层协议混淆。
   
   4.2.3。向后兼容性 
   使用ICE的要求限制了与传统非ICE客户端的兼容性。完全取消某些检查的要求似乎是不安全的。所有被提出的检查都有一个共同特征，即浏览器向候选流量接收者发送一些消息并且拒绝发送其他流量直到该消息被回复。
   必须以这样的方式生成消息/回复对：
   通常是通过使消息包含一些必须生成的某些秘钥值（例如，回显，散列等）使得控制Web应用程序的攻击者不能伪造它们。
   此角色可以为非ICE候选者（在遗留端点具有公共地址的情况下）包括：
   1. STUN不使用ICE进行检查（即非RTC-web端点设置STUN响应器。）
   2. 使用RTCP作为隐式可达性检查。

   在RTCP方法中，允许WebRTC端点在接收同意之前发送有限数量的RTP数据包。这允许短暂的攻击窗口。此外，一些传统端点不支持RTCP，因此对于此类端点而言，这是一种更昂贵的解决方案，这样的话可能更容易实现ICE。出于这两个原因，基于RTCP的方法似乎并未
   令人满意地解决安全问题。

   在STUN方法中，WebRTC端点能够验证接收方是否正在运行某种STUN端点，但除非STUN
   响应者与ICE用户名/密码建立系统集成在一起，WebRTC端点无法验证接收方是否同意
   这个特定呼叫。如果现有STUN服务器在无法处理基于带宽的攻击的地址上运行，那么这可能是一个问题。因此，这种方法似乎也不能够令人满意。





　　如果系统是紧密集成的（即STUN端点响应使用ICE凭证进行身份验证的响应），则此问题不存在。然而，这样的设计非常接近ICE-Lite实现（实际上可以说就是）。一种中间方法是使用STUN扩展，表明一个人正在响应WebRTC检验，但没有根据ICE凭证计算完整性检验。 这将允许使用独立的STUN服务器，而不会有将它们与传统STUN服务器混淆的风险。如果需要非ICE传统解决方案，这可能是最佳选择。
　　一旦初步同意得到验证，我们还需要验证继续同意，以避免两个人短暂共享IP的攻击（例如，在网吧中的NAT）和攻击者使大量的不可阻挡的流量进入网络。这里的适用技术与初始同意的技术非常相似，但由于威胁不那么严重，因此技术可能较弱。

4.2.4. IP 位置隐私 
	
	请注意，一旦被叫者发送其ICE候选者，调用者就会获知被叫方的IP地址。被叫者的服务器自反地址显示了有关被叫者位置的大量信息。为了避免跟踪，希望实现抑制ICE协商的起始，直到被叫者应答。

	此外，任何一方可能希望通过强制所有流量通过一个TURN服务器完全隐藏自己的位置。
	在普通操作中，网站会学习浏览器的IP地址，但可能会通过Tor [http://www.torproject.org]或VPN等机制隐藏。但是，由于站点可以使浏览器提供IP地址，因此即使用户位于掩盖其IP地址的VPN之后，也可以为站点提供了解用户网络环境的机制。如果用户使用特定类型的VPN，特别是面向隐私的系统（如Tor），实现可能希望提供抑制所有非VPN候选者的设置。

4.3. 通信安全 

	最后，我们考虑SIP世界熟悉的问题：通信安全。出于显而易见的原因，通信方必须能够建立一个对消息恢复和消息修改都是安全的信道。（详细有关信息，请参阅[RFC5479]。）这项服务必须为数据和语音/视频提供。理想情况下，两种类型的内容都将使用相同的安全机制。 提供此服务的技术（例如，SRTP [RFC3711],DTLS [RFC6347]和DTLS-SRTP [RFC5763]）已被充分理解。但是，我们必须在WebRTC上下文中检查此技术，其中威胁模型有些不同。
　　
　　虽然原则上浏览器可以将调用服务从循环中删除并直接呈现可信信息（并且可能获得同意），但现代浏览器中的实践是尽可能避免这种情况。需要用户同意特定行动的“流动”模式对话特别不受欢迎，因为人为因素研究表明，除非它们具有极强的侵入性，否则用户只需同意他们实际上无意识同意的对话。[abarth-rtcweb]。因此，几乎所有的UI都必须由浏览器呈现，但是是在调用服务的控制下。这可能包括对等方的身份信息，毕竟这些信息仅在某些调用服务的上下文中有意义。
　　
	这种限制并不意味着防止调用服务的攻击完全没有希望。 但是，我们需要区分两类攻击：
　　调用服务的回顾性妥协。
        调用服务在调用期间是非恶意的，但随后受到了攻击并意图攻击较旧的调用（通常称为“被动攻击”）
	通过调用服务进行调用中的攻击。
      	调用服务在其希望攻击的调用期间受到了攻击（通常称为“主动攻击”）。
   
　　使用第4.3.1节中讨论的技术可以提供针对前一类攻击的安全性。 但是，通过安装MITM攻击或完全转移它们来防止可信但恶意的 调用服务主动攻击用户的 调用是极其困难的。 （请注意，如果与调用服务的通信不安全，则此攻击同样适用于网络攻击者。）我们将讨论一些可能的方法以及为什么它们在第4.3.2节中可能不切实际。

4.3.1.  防止追溯性妥协
	
　　在回溯性攻击中，调用服务在调用期间是不妥协的，但攻击者随后想要恢复调用的内容。 我们假设攻击者可以访问受保护的媒体流，并且可以完全控制调用服务。
　　
　　如果调用服务可以访问流量密钥材料（如SDES [RFC4568]），则回溯攻击是微不足道的。 这种形式的攻击在Web上下文中尤其严重，因为Web服务中的标准做法是运行广泛的日志记录和监视。因此，如果流量密钥很有可能是任何HTTP请求的一部分，则它将被记录在某处，从而受到后续的损害。正是这种考虑使得基于公钥的自动密钥交换机制对WebRTC来说势在必行（这对任何通信安全系统来说都是一个好主意），这种机制应该提供完美的前向保密（PFS）。 信令通道/调用服务可用于验证该机制。

	此外，如果使用端到端密钥，系统绝不能提供任何API来提取长期密钥材料或直接访问任何存储的流量密钥。否则，随后攻击服务的攻击者可能能够使用这些API来恢复流量密钥，从而危及流量。
	
4.3.2． 防止调用期间的攻击
	
　　在调用期间防止攻击是一个更难的主张。即使调用服务无法直接访问密钥资料（如上一节所述），它也可以简单地在连接上发起中间人攻击，告诉Alice她正在调用Bob和Bob他正在调用Alice，但实际上，调用服务充当调用桥并捕获所有流量。防止这种形式的攻击需要对远程端点进行正面认证，例如明确的带外密钥验证（例如，通过指纹）或第三方身份服务如[ID.ietf-rtcweb-security-arch]中所述。

4.3.2.1  密钥连续性 
	一种自然的方法是使用“密钥连续性”。虽然恶意调用服务可以向用户显示它选择的任何身份，但它不能生成映射到给定公钥的私钥。因此，浏览器可以记录给定用户的公钥，并在该用户的密钥改变时生成警报。SSH [RFC4251]使用类似的技术。（请注意，在每次调用时都需要避免明确的用户同意，这就要求浏览器需要立即手动检查对方的密钥）。

　　不幸的是，这种关键的连续性机制在WebRTC上下文中没那么有用。首先，WebRTC（以及任何Web应用程序）的许多优点是它不受特定客户端软件的约束。 因此，用户在不同的计算机上使用多个浏览器不仅是可能的而且是常规的，当然这些浏览器具有不同的密钥材料（SACRED [RFC3760]notwithstanding）。因此，用户将经常被提示实际上是合法的密钥不匹配，结果是他们被训练简单的点击它们。众所周知，用户通常会点击更严重的警告[cranor-wolf]，看起来似乎任何密钥连续性机制都不太可能是有效而仅仅是惹人心烦的。

	而且，甚至绕过这种机制也是微不足道的。回想一下，与SSH的情况不同，浏览器永远不会直接从用户获取对等方的身份。相反，它由调用服务提供。即使启用这种类型的机制也需要API来允许调用服务告诉浏览器“这是对用户X的调用”。所有调用服务为避免触发密钥连续性警告，需要告诉浏览器“这是对用户Y的调用”，其中Y与X相似。即使用户实际检查对方的名称（全部可用证据表明不太可能），这将要求（a）浏览器向受信任的UI提供名称，以及（b）用户不要被类似的出现名称所欺骗。

4.3.2.2  短认证字符串 

   ZRTP [RFC6189]使用从密钥协商协议派生的“短认证字符串”（SAS）。 该SAS被设计为由用户进行比较（例如，通过语音信道朗读或通过带外信道发送），并且双方确认是否排除MITM攻击。目的是使用SAS一次，然后使用密钥连续性（尽管与上面讨论的机制不同）。

	不幸的是，SAS没有为受攻击的调用服务问题提供实用的解决方案。“语音转换”系统是一个活跃的研究领域，它可以修改一个扬声器的声音，使其听起来像另一个扬声器。 在很多情况下，这些系统已经足够愚弄自动识别系统[farus-conversion]和人类[kain-conversion]，并且当然可能在将来有所改进，特别是在用户只想打电话的环境中。因此，即使SAS今天有效，不久后也可能不会有效。

	此外，尚不清楚用户是否会实际使用SAS。如上所述，浏览器UI约束排除了在完成呼叫之前需要SAS交换，因此它必须是自愿的；最多浏览器可提供一些尚未检查SAS的UI指示符。然而，众所周知，当面对可选的安全机制时，许多用户只是忽略它们[whitten-johnny]。

	一旦用户检查了一次SAS，就需要密钥连续性以避免他们需要在每次调用时检查它。但是，由于第4.3.2.1节中所述的原因，这样是有问题的。原则上，当然可以呈现不同的UI元素来指示调用正在使用未经验证的密钥材料集（回想一下，攻击者可以只提供稍微不同的名称，攻击就可以在向一台新设备或者从未呼叫过的用户调用时显示相同的UI），但实际上即使在混合内容警告的更加严重的情况下，用户也会忽略这些指标。

4.3.2.3.  第三方身份
  
提供通信身份的传统方法，当然是具有一些第三方身份系统（例如，PKI）来
 验证端点。这种机制已被证明是过于繁琐供一般用户的使用（过于繁琐
对于管理员）。然而，最近开发了新一代基于Web的身份提供商（BrowserID，Federated Google Login，Facebook Connect，OAuth，OpenID，WebFinger），并使用Web 技术提供轻量级（从用户的角度来看）第三方认证交易。可以使用这种类型的系统来验证WebRTC呼叫，将它们链接到现有用户的身份概念（例如，Facebook邻接）。具体而言，第三方身份系统用于将用户的身份绑定到加密密钥材料，然后用于验证呼叫端点。经过身份验证的呼叫以这种方式即使对于主叫站点的主动MITM攻击也是自然抗性的。

   
请注意，有一种特殊情况，其中PKI样式的证书确实提供了实用的解决方案：从最终用户到大型站点的呼叫。例如，如果您打电话给Amazon.com，那么亚马逊可以轻松获得证书来验证他们的媒体流量，就像他们获得一个验证他们的网络流量一样。在呼叫站点和媒体对等体是同一个的情况下，这不提供额外的安全价值，但在第三方（例如，广告网络或零售商）安排呼叫但不参与呼叫的情况下可能有用

4.3.2.4.  页面访问媒体
   
识别远媒体端点的身份是提供媒体安全性的必要条件，但不是充分条件。在WebRTC中，媒体流被渲染为HTML5 MediaStream，可以由调用站点操纵。显然，如果站点可以修改或查看媒体，那么用户无法获得他们期望能够对其对等方进行身份验证的保证级别。在许多情况下，这是可以接受的，因为用户重视基于站点的特殊效果，而不是来自站点的完全安全性。但是，也有用户希望知道该网站的情况
不能干涉。为了促进这一点，有必要提供一些功能，使网站可以可验证地放弃对媒体流的访问。必须可以从本地侧和远程侧进行此验证。即，我必须能够验证
我呼叫的人是否采用了安全媒体模式。为了实现这一点，有必要将本地媒体访问策略的指示加密地绑定到前面部分中详述的加密认证过程中。
4.3.3.  恶意同行
  

我们通常不会试图阻止的一类攻击是恶意同行。例如，无论您采用何种保密措施，您正在与之交谈的人都可以记录呼叫并将其发布到互联网上。同样，我们也不会试图阻止他们使用语音或视频处理技术隐藏或改变其外观。虽然确实存在技术（DRM等）以试图解决这些问题，但它们通常与开放系统不兼容，并且WebRTC不解决它们。
   
同样，我们不会试图阻止恶作剧电话或其他不必要的电话。通常，这是在调用的范围内网站，虽然因为WebRTC确实提供了某种形式的强身份验证，这可能有助于防范此类攻击。



4.4.  隐私考虑因素
4.4.1.  匿名呼叫的相关性
   
虽然持久端点标识符可以是一个有用的安全功能（参见第4.3.2.1节，它们也可以代表用户希望匿名的设置中的隐私威胁.WebRTC提供了许多可能的持久标识符，如DTLS证书（如果它们在连接之间重用）和RTCP CNAMES （如果根据[RFC6222]生成而不是[RFC7022]的隐私保护模式）。为了防止这种类型的关联，浏览器需要提供重置这些标识符的机制（例如，与cookie的生命周期相同）。此外，API应该提供允许用于匿名呼叫的站点强制创建新标识符的机制。此外，IP地址可以是呼叫链接的来源[ID.ietf-rtcweb-ip-handling]
4.4.2.浏览器指纹识别
  
任何新的API功能都会增加浏览器指纹识别的风险，WebRTC也不例外。具体而言，站点可以使用特定设备的存在或不存在作为浏览器指纹。通常，API需要在功能和
增量指纹风险之间进行平衡。





5.安全注意事项
 
   整个文档都是关于安全的。